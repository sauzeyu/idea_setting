<application>
  <component name="AppStorage">
    <option name="lastReplacementTargetLanguage" value="ENGLISH" />
    <option name="newTranslationDialogHeight" value="404" />
    <option name="newTranslationDialogWidth" value="767" />
    <option name="newTranslationDialogX" value="1208" />
    <option name="newTranslationDialogY" value="580" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="Point not on curve" />
      <item value="Initializes the key pair generator for a certain keysize with the given source of randomness (and a default parameter set).&#10;Params:&#10;keysize – the keysize. This is an algorithm-specific metric, such as modulus length, specified in number of bits.&#10;random – the source of randomness.&#10;Throws:&#10;InvalidParameterException – if the keysize is not supported by this KeyPairGenerator object." />
      <item value="secret" />
      <item value="Non-static method cannot be referenced from a static context" />
      <item value="Cannot resolve method 'ok(java.lang.String, long, java.util.List&lt;com.vecentek.back.entity.DkmAdmin&gt;)'" />
      <item value="Unsatisfied dependency expressed through bean property 'sqlSessionFactory'; nested exception is org.springframework.beans.factory" />
      <item value="nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'dkmAdminServiceImpl': Injection of resource dependencies failed; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'dkmAdminMapper' defined in file " />
      <item value="Injection" />
      <item value="batch" />
      <item value="Non-static method cannot be referenced from a static contexT" />
      <item value="Non-static method cannot be referenced from a static contex" />
      <item value="Enables Spring's annotation-driven transaction management capability, similar to the support found in Spring's &lt;tx:&gt; XML namespace. To be used on @Configuration classes to configure traditional, imperative transaction management or reactive transaction management.&#10;The following example demonstrates imperative transaction management using a PlatformTransactionManager. For reactive transaction management, configure a ReactiveTransactionManager instead.&#10;   @Configuration&#10;   @EnableTransactionManagement&#10;   public class AppConfig {&#10;  &#10;       @Bean&#10;       public FooRepository fooRepository() {&#10;            configure and return a class having @Transactional methods&#10;           return new JdbcFooRepository(dataSource());&#10;       }&#10;  &#10;       @Bean&#10;       public DataSource dataSource() {&#10;            configure and return the necessary JDBC DataSource&#10;       }&#10;  &#10;       @Bean&#10;       public PlatformTransactionManager txManager() {&#10;           return new DataSourceTransactionManager(dataSource());&#10;       }&#10;   }&#10;For reference, the example above can be compared to the following Spring XML configuration:&#10;   &lt;beans&gt;&#10;  &#10;       &lt;tx:annotation-driven&gt;&#10;  &#10;       &lt;bean id=&quot;fooRepository&quot; class=&quot;com.foo.JdbcFooRepository&quot;&gt;&#10;           &lt;constructor-arg ref=&quot;dataSource&quot;&gt;&#10;       &lt;bean&gt;&#10;  &#10;       &lt;bean id=&quot;dataSource&quot; class=&quot;com.vendor.VendorDataSource&quot;&gt;&#10;  &#10;       &lt;bean id=&quot;transactionManager&quot; class=&quot;org.sfwk...DataSourceTransactionManager&quot;&gt;&#10;           &lt;constructor-arg ref=&quot;dataSource&quot;&gt;&#10;       &lt;bean&gt;&#10;  &#10;   &lt;beans&gt;&#10;   &#10;In both of the scenarios above, @EnableTransactionManagement and &lt;tx:annotation-driven&gt; are responsible for registering the necessary Spring components that power annotation-driven transaction management, such as the TransactionInterceptor and the proxy- or AspectJ-based advice that weave the interceptor into the call stack when JdbcFooRepository's @Transactional methods are invoked.&#10;A minor difference between the two examples lies in the naming of the TransactionManager bean: In the @Bean case, the name is &quot;txManager&quot; (per the name of the method); in the XML case, the name is &quot;transactionManager&quot;. The &lt;tx:annotation-driven&gt; is hard-wired to look for a bean named &quot;transactionManager&quot; by default, however @EnableTransactionManagement is more flexible; it will fall back to a by-type lookup for any TransactionManager bean in the container. Thus the name can be &quot;txManager&quot;, &quot;transactionManager&quot;, or &quot;tm&quot;: it simply does not matter.&#10;For those that wish to establish a more direct relationship between @EnableTransactionManagement and the exact transaction manager bean to be used, the TransactionManagementConfigurer callback interface may be implemented - notice the implements clause and the @Override-annotated method below:&#10;   @Configuration&#10;   @EnableTransactionManagement&#10;   public class AppConfig implements TransactionManagementConfigurer {&#10;  &#10;       @Bean&#10;       public FooRepository fooRepository() {&#10;            configure and return a class having @Transactional methods&#10;           return new JdbcFooRepository(dataSource());&#10;       }&#10;  &#10;       @Bean&#10;       public DataSource dataSource() {&#10;            configure and return the necessary JDBC DataSource&#10;       }&#10;  &#10;       @Bean&#10;       public PlatformTransactionManager txManager() {&#10;           return new DataSourceTransactionManager(dataSource());&#10;       }&#10;  &#10;       @Override&#10;       public PlatformTransactionManager annotationDrivenTransactionManager() {&#10;           return txManager();&#10;       }&#10;   }&#10;This approach may be desirable simply because it is more explicit, or it may be necessary in order to distinguish between two TransactionManager beans present in the same container. As the name suggests, the annotationDrivenTransactionManager() will be the one used for processing @Transactional methods. See TransactionManagementConfigurer Javadoc for further details.&#10;The mode attribute controls how advice is applied: If the mode is AdviceMode.PROXY (the default), then the other attributes control the behavior of the proxying. Please note that proxy mode allows for interception of calls through the proxy only; local calls within the same class cannot get intercepted that way.&#10;Note that if the mode is set to AdviceMode.ASPECTJ, then the value of the proxyTargetClass attribute will be ignored. Note also that in this case the spring-aspects module JAR must be present on the classpath, with compile-time weaving or load-time weaving applying the aspect to the affected classes. There is no proxy involved in such a scenario; local calls will be intercepted as well." />
      <item value="trace" />
      <item value="Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection's iterator (optional operation). The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (Note that this will occur if the specified collection is this list, and it's nonempty.)&#10;Params:&#10;c – collection containing elements to be added to this list&#10;Returns:&#10;true if this list changed as a result of the call" />
      <item value="Contents of collection 'errorVinList' are updated, but never queried" />
      <item value="Returns true if this collection contains no elements.&#10;Returns:&#10;true if this collection contains no elements" />
      <item value="dynamic" />
      <item value="parse" />
      <item value="Indicate that message handling is complete, allowing for any cleanup or end-of-processing tasks to be performed such as applying header changes made via getHeaders() to the underlying HTTP message (if not applied already).&#10;This method should be automatically invoked at the end of message processing so typically applications should not have to invoke it. If invoked multiple times it should have no side effects.&#10;Returns:&#10;a Mono that indicates completion or error" />
      <item value="Set the HTTP status code to the given value (potentially non-standard and not resolvable through the HttpStatus enum) as an integer.&#10;Params:&#10;value – the status code value&#10;Returns:&#10;false if the status code change wasn't processed because the HTTP response is committed, true if successfully set.&#10;Since:&#10;5.2.4" />
      <item value="Unauthorized" />
      <item value="Reset Content" />
      <item value="Non-Authoritative Information" />
      <item value="Not Acceptable." />
      <item value="402 Payment Required." />
      <item value="00 Bad Request." />
      <item value="Return the first header value for the given header name, if any.&#10;Params:&#10;headerName – the header name&#10;Returns:&#10;the first header value, or null if none" />
      <item value="生成" />
      <item value="Unchecked cast: 'java.lang.String' to 'T'" />
      <item value="Method invocation 'msg' may produce 'NullPointerException' " />
      <item value="Generates implementations for the equals and hashCode methods inherited by all objects, based on relevant fields." />
      <item value="Method 'put()' recurses infinitely, and can only end by throwing an exception" />
      <item value="Object" />
      <item value="key – key with which the specified value is to be associated" />
      <item value="Claims" />
      <item value="Sets a custom JWT Claims parameter value. A null value will remove the property from the Claims.&#10;This is a convenience method. It will first ensure a Claims instance exists as the JWT body and then set the named property on the Claims instance using the Claims put method. This allows you to write code like this:" />
      <item value="Sets a custom JWT Claims parameter value. A null value will remove the property from the Claims.&#10;This is a convenience method. It will first ensure a Claims instance exists as the JWT body and then set the named property on the Claims instance using the Claims put method. This allows you to write code like this:&#10;       String jwt = Jwts.builder().claim(&quot;aName&quot;, &quot;aValue&quot;).compact();&#10;       &#10;instead of this:&#10;       Claims claims = Jwts.claims().put(&quot;aName&quot;, &quot;aValue&quot;);&#10;       String jwt = Jwts.builder().setClaims(claims).compact();&#10;       &#10;if desired.&#10;Params:&#10;name – the JWT Claims property name&#10;value – the value to set for the specified Claims property name&#10;Returns:&#10;the builder instance for method chaining." />
      <item value="Sets the JWT Claims exp (expiration) value. A null value will remove the property from the Claims.&#10;A JWT obtained after this timestamp should not be used.&#10;This is a convenience method. It will first ensure a Claims instance exists as the JWT body and then set the Claims expiration field with the specified value. This allows you to write code like this:&#10;       String jwt = Jwts.builder().setExpiration(new Date(System.currentTimeMillis() + 3600000)).compact();&#10;       &#10;instead of this:&#10;       Claims claims = Jwts.claims().setExpiration(new Date(System.currentTimeMillis() + 3600000));&#10;       String jwt = Jwts.builder().setClaims(claims).compact();&#10;       &#10;if desired.&#10;Params:&#10;exp – the JWT exp value or null to remove the property from the Claims map.&#10;Returns:&#10;the builder instance for method chaining." />
      <item value="replace default Configuration class" />
      <item value="dangling" />
      <item value="Dangling" />
      <item value="segment" />
      <item value="authority" />
      <item value="Return the body of the message as a Publisher.&#10;Returns:&#10;the body content publisher" />
      <item value="Return the request attribute value or if not present raise an" />
      <item value="Return the current HTTP request." />
      <item value="An &quot;reactive&quot; HTTP input message that exposes the input as Publisher.&#10;Typically implemented by an HTTP request on the server-side or a response on the client-side." />
      <item value="Defines an object to provide client request information to a servlet. The servlet container creates a ServletRequest object and passes it as an argument to the servlet's service method.&#10;A ServletRequest object provides data including parameter name and values, attributes, and an input stream. Interfaces that extend ServletRequest can provide additional protocol-specific data (for example, HTTP data is provided by javax.servlet.http.HttpServletRequest.&#10;See Also:&#10;javax.servlet.http.HttpServletRequest" />
      <item value="A Publisher is a provider of a potentially unbounded number of sequenced elements, publishing them according to the demand received from its Subscriber(s).&#10;A Publisher can serve multiple Subscribers subscribed subscribe(Subscriber) dynamically at various points in time.&#10;Type parameters:&#10;&lt;T&gt; – the type of element signaled." />
      <item value="A Reactive Streams Publisher with rx operators that emits 0 to N elements, and then completes (successfully or with an error).&#10;The recommended way to learn about the Flux API and discover new operators is through the reference documentation, rather than through this javadoc (as opposed to learning more about individual operators). See the &quot;which operator do I need?&quot; appendix .&#10; &#10;It is intended to be used in implementations and return types. Input parameters should keep using raw Publisher as much as possible.&#10;If it is known that the underlying Publisher will emit 0 or 1 element, Mono should be used instead.&#10;Note that using state in the java.util.function  lambdas used within Flux operators should be avoided, as these may be shared between several Subscribers.&#10;subscribe(CoreSubscriber) is an internal extension to subscribe(Subscriber) used internally for Context passing. User provided Subscriber may be passed to this &quot;subscribe&quot; extension but will loose the available per-subscribe Hooks.onLastOperator." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1209" />
        <entry key="ENGLISH" value="1210" />
        <entry key="DANISH" value="2" />
        <entry key="FRISIAN" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="JAPANESE" value="1" />
        <entry key="INDONESIAN" value="2" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1648088411178" />
  </component>
  <component name="Settings">
    <option name="autoReplace" value="true" />
    <option name="keepFormat" value="true" />
    <option name="selectTargetLanguageBeforeReplacement" value="true" />
    <option name="showActionsInContextMenuOnlyWithSelection" value="false" />
    <option name="showExplanation" value="true" />
    <option name="showWordsOnStartup" value="true" />
    <option name="translateDocumentation" value="true" />
  </component>
</application>