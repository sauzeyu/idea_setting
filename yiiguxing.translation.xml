<application>
  <component name="AppStorage">
    <option name="lastReplacementTargetLanguage" value="ENGLISH" />
    <option name="newTranslationDialogHeight" value="404" />
    <option name="newTranslationDialogWidth" value="765" />
    <option name="newTranslationDialogX" value="1208" />
    <option name="newTranslationDialogY" value="580" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="Unreachable" />
      <item value="Throwable argument 'e' to 'System.out.println()' call " />
      <item value="Provides programmatic access to the stack trace information printed by printStackTrace(). Returns an array of stack trace elements, each representing one stack frame. The zeroth element of the array (assuming the array's length is non-zero) represents the top of the stack, which is the last method invocation in the sequence. Typically, this is the point at which this throwable was created and thrown. The last element of the array (assuming the array's length is non-zero) represents the bottom of the stack, which is the first method invocation in the sequence.&#10;Some virtual machines may, under some circumstances, omit one or more stack frames from the stack trace. In the extreme case, a virtual machine that has no stack trace information concerning this throwable is permitted to return a zero-length array from this method. Generally speaking, the array returned by this method will contain one element for every frame that would be printed by printStackTrace. Writes to the returned array do not affect future calls to this method.&#10;Returns:&#10;an array of stack trace elements representing the stack trace pertaining to this throwable." />
      <item value="Contents of collection 'errorVinList' are updated, but never queried " />
      <item value="SQL Integrity Constraint Violation Exception" />
      <item value="Returns the detail message string of this throwable.&#10;Returns:&#10;the detail message string of this Throwable instance (which may be null)." />
      <item value="Constructs a new throwable with the specified detail message. The cause is not initialized, and may subsequently be initialized by a call to initCause.&#10;The fillInStackTrace() method is called to initialize the stack trace data in the newly created throwable.&#10;Params:&#10;message – the detail message. The detail message is saved for later retrieval by the getMessage() method." />
      <item value="Specific details about the Throwable. For example, for FileNotFoundException, this contains the name of the file that could not be found." />
      <item value="Point not on curve" />
      <item value="Initializes the key pair generator for a certain keysize with the given source of randomness (and a default parameter set).&#10;Params:&#10;keysize – the keysize. This is an algorithm-specific metric, such as modulus length, specified in number of bits.&#10;random – the source of randomness.&#10;Throws:&#10;InvalidParameterException – if the keysize is not supported by this KeyPairGenerator object." />
      <item value="secret" />
      <item value="Non-static method cannot be referenced from a static context" />
      <item value="Cannot resolve method 'ok(java.lang.String, long, java.util.List&lt;com.vecentek.back.entity.DkmAdmin&gt;)'" />
      <item value="Unsatisfied dependency expressed through bean property 'sqlSessionFactory'; nested exception is org.springframework.beans.factory" />
      <item value="nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'dkmAdminServiceImpl': Injection of resource dependencies failed; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'dkmAdminMapper' defined in file " />
      <item value="Injection" />
      <item value="batch" />
      <item value="Non-static method cannot be referenced from a static contexT" />
      <item value="Non-static method cannot be referenced from a static contex" />
      <item value="Enables Spring's annotation-driven transaction management capability, similar to the support found in Spring's &lt;tx:&gt; XML namespace. To be used on @Configuration classes to configure traditional, imperative transaction management or reactive transaction management.&#10;The following example demonstrates imperative transaction management using a PlatformTransactionManager. For reactive transaction management, configure a ReactiveTransactionManager instead.&#10;   @Configuration&#10;   @EnableTransactionManagement&#10;   public class AppConfig {&#10;  &#10;       @Bean&#10;       public FooRepository fooRepository() {&#10;            configure and return a class having @Transactional methods&#10;           return new JdbcFooRepository(dataSource());&#10;       }&#10;  &#10;       @Bean&#10;       public DataSource dataSource() {&#10;            configure and return the necessary JDBC DataSource&#10;       }&#10;  &#10;       @Bean&#10;       public PlatformTransactionManager txManager() {&#10;           return new DataSourceTransactionManager(dataSource());&#10;       }&#10;   }&#10;For reference, the example above can be compared to the following Spring XML configuration:&#10;   &lt;beans&gt;&#10;  &#10;       &lt;tx:annotation-driven&gt;&#10;  &#10;       &lt;bean id=&quot;fooRepository&quot; class=&quot;com.foo.JdbcFooRepository&quot;&gt;&#10;           &lt;constructor-arg ref=&quot;dataSource&quot;&gt;&#10;       &lt;bean&gt;&#10;  &#10;       &lt;bean id=&quot;dataSource&quot; class=&quot;com.vendor.VendorDataSource&quot;&gt;&#10;  &#10;       &lt;bean id=&quot;transactionManager&quot; class=&quot;org.sfwk...DataSourceTransactionManager&quot;&gt;&#10;           &lt;constructor-arg ref=&quot;dataSource&quot;&gt;&#10;       &lt;bean&gt;&#10;  &#10;   &lt;beans&gt;&#10;   &#10;In both of the scenarios above, @EnableTransactionManagement and &lt;tx:annotation-driven&gt; are responsible for registering the necessary Spring components that power annotation-driven transaction management, such as the TransactionInterceptor and the proxy- or AspectJ-based advice that weave the interceptor into the call stack when JdbcFooRepository's @Transactional methods are invoked.&#10;A minor difference between the two examples lies in the naming of the TransactionManager bean: In the @Bean case, the name is &quot;txManager&quot; (per the name of the method); in the XML case, the name is &quot;transactionManager&quot;. The &lt;tx:annotation-driven&gt; is hard-wired to look for a bean named &quot;transactionManager&quot; by default, however @EnableTransactionManagement is more flexible; it will fall back to a by-type lookup for any TransactionManager bean in the container. Thus the name can be &quot;txManager&quot;, &quot;transactionManager&quot;, or &quot;tm&quot;: it simply does not matter.&#10;For those that wish to establish a more direct relationship between @EnableTransactionManagement and the exact transaction manager bean to be used, the TransactionManagementConfigurer callback interface may be implemented - notice the implements clause and the @Override-annotated method below:&#10;   @Configuration&#10;   @EnableTransactionManagement&#10;   public class AppConfig implements TransactionManagementConfigurer {&#10;  &#10;       @Bean&#10;       public FooRepository fooRepository() {&#10;            configure and return a class having @Transactional methods&#10;           return new JdbcFooRepository(dataSource());&#10;       }&#10;  &#10;       @Bean&#10;       public DataSource dataSource() {&#10;            configure and return the necessary JDBC DataSource&#10;       }&#10;  &#10;       @Bean&#10;       public PlatformTransactionManager txManager() {&#10;           return new DataSourceTransactionManager(dataSource());&#10;       }&#10;  &#10;       @Override&#10;       public PlatformTransactionManager annotationDrivenTransactionManager() {&#10;           return txManager();&#10;       }&#10;   }&#10;This approach may be desirable simply because it is more explicit, or it may be necessary in order to distinguish between two TransactionManager beans present in the same container. As the name suggests, the annotationDrivenTransactionManager() will be the one used for processing @Transactional methods. See TransactionManagementConfigurer Javadoc for further details.&#10;The mode attribute controls how advice is applied: If the mode is AdviceMode.PROXY (the default), then the other attributes control the behavior of the proxying. Please note that proxy mode allows for interception of calls through the proxy only; local calls within the same class cannot get intercepted that way.&#10;Note that if the mode is set to AdviceMode.ASPECTJ, then the value of the proxyTargetClass attribute will be ignored. Note also that in this case the spring-aspects module JAR must be present on the classpath, with compile-time weaving or load-time weaving applying the aspect to the affected classes. There is no proxy involved in such a scenario; local calls will be intercepted as well." />
      <item value="trace" />
      <item value="Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection's iterator (optional operation). The behavior of this operation is undefined if the specified collection is modified while the operation is in progress. (Note that this will occur if the specified collection is this list, and it's nonempty.)&#10;Params:&#10;c – collection containing elements to be added to this list&#10;Returns:&#10;true if this list changed as a result of the call" />
      <item value="Contents of collection 'errorVinList' are updated, but never queried" />
      <item value="Returns true if this collection contains no elements.&#10;Returns:&#10;true if this collection contains no elements" />
      <item value="dynamic" />
      <item value="parse" />
      <item value="Indicate that message handling is complete, allowing for any cleanup or end-of-processing tasks to be performed such as applying header changes made via getHeaders() to the underlying HTTP message (if not applied already).&#10;This method should be automatically invoked at the end of message processing so typically applications should not have to invoke it. If invoked multiple times it should have no side effects.&#10;Returns:&#10;a Mono that indicates completion or error" />
      <item value="Set the HTTP status code to the given value (potentially non-standard and not resolvable through the HttpStatus enum) as an integer.&#10;Params:&#10;value – the status code value&#10;Returns:&#10;false if the status code change wasn't processed because the HTTP response is committed, true if successfully set.&#10;Since:&#10;5.2.4" />
      <item value="Unauthorized" />
      <item value="Reset Content" />
      <item value="Non-Authoritative Information" />
      <item value="Not Acceptable." />
      <item value="402 Payment Required." />
      <item value="00 Bad Request." />
      <item value="Return the first header value for the given header name, if any.&#10;Params:&#10;headerName – the header name&#10;Returns:&#10;the first header value, or null if none" />
      <item value="生成" />
      <item value="Unchecked cast: 'java.lang.String' to 'T'" />
      <item value="Method invocation 'msg' may produce 'NullPointerException' " />
      <item value="Generates implementations for the equals and hashCode methods inherited by all objects, based on relevant fields." />
      <item value="Method 'put()' recurses infinitely, and can only end by throwing an exception" />
      <item value="Object" />
      <item value="key – key with which the specified value is to be associated" />
      <item value="Claims" />
      <item value="Sets a custom JWT Claims parameter value. A null value will remove the property from the Claims.&#10;This is a convenience method. It will first ensure a Claims instance exists as the JWT body and then set the named property on the Claims instance using the Claims put method. This allows you to write code like this:" />
      <item value="Sets a custom JWT Claims parameter value. A null value will remove the property from the Claims.&#10;This is a convenience method. It will first ensure a Claims instance exists as the JWT body and then set the named property on the Claims instance using the Claims put method. This allows you to write code like this:&#10;       String jwt = Jwts.builder().claim(&quot;aName&quot;, &quot;aValue&quot;).compact();&#10;       &#10;instead of this:&#10;       Claims claims = Jwts.claims().put(&quot;aName&quot;, &quot;aValue&quot;);&#10;       String jwt = Jwts.builder().setClaims(claims).compact();&#10;       &#10;if desired.&#10;Params:&#10;name – the JWT Claims property name&#10;value – the value to set for the specified Claims property name&#10;Returns:&#10;the builder instance for method chaining." />
      <item value="Sets the JWT Claims exp (expiration) value. A null value will remove the property from the Claims.&#10;A JWT obtained after this timestamp should not be used.&#10;This is a convenience method. It will first ensure a Claims instance exists as the JWT body and then set the Claims expiration field with the specified value. This allows you to write code like this:&#10;       String jwt = Jwts.builder().setExpiration(new Date(System.currentTimeMillis() + 3600000)).compact();&#10;       &#10;instead of this:&#10;       Claims claims = Jwts.claims().setExpiration(new Date(System.currentTimeMillis() + 3600000));&#10;       String jwt = Jwts.builder().setClaims(claims).compact();&#10;       &#10;if desired.&#10;Params:&#10;exp – the JWT exp value or null to remove the property from the Claims map.&#10;Returns:&#10;the builder instance for method chaining." />
      <item value="replace default Configuration class" />
      <item value="dangling" />
      <item value="Dangling" />
      <item value="segment" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1218" />
        <entry key="ENGLISH" value="1217" />
        <entry key="DANISH" value="2" />
        <entry key="FRISIAN" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="JAPANESE" value="1" />
        <entry key="INDONESIAN" value="2" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1648088411178" />
  </component>
  <component name="Settings">
    <option name="autoReplace" value="true" />
    <option name="keepFormat" value="true" />
    <option name="selectTargetLanguageBeforeReplacement" value="true" />
    <option name="showActionsInContextMenuOnlyWithSelection" value="false" />
    <option name="showExplanation" value="true" />
    <option name="showWordsOnStartup" value="true" />
    <option name="translateDocumentation" value="true" />
  </component>
</application>