<application>
  <component name="AppStorage">
    <option name="lastReplacementTargetLanguage" value="ENGLISH" />
    <option name="newTranslationDialogHeight" value="404" />
    <option name="newTranslationDialogWidth" value="611" />
    <option name="newTranslationDialogX" value="1208" />
    <option name="newTranslationDialogY" value="580" />
    <option name="pinNewTranslationDialog" value="true" />
    <histories>
      <item value="Method invocation 'msg' may produce 'NullPointerException' " />
      <item value="Generates implementations for the equals and hashCode methods inherited by all objects, based on relevant fields." />
      <item value="Method 'put()' recurses infinitely, and can only end by throwing an exception" />
      <item value="Object" />
      <item value="key – key with which the specified value is to be associated" />
      <item value="Claims" />
      <item value="Sets a custom JWT Claims parameter value. A null value will remove the property from the Claims.&#10;This is a convenience method. It will first ensure a Claims instance exists as the JWT body and then set the named property on the Claims instance using the Claims put method. This allows you to write code like this:" />
      <item value="Sets a custom JWT Claims parameter value. A null value will remove the property from the Claims.&#10;This is a convenience method. It will first ensure a Claims instance exists as the JWT body and then set the named property on the Claims instance using the Claims put method. This allows you to write code like this:&#10;       String jwt = Jwts.builder().claim(&quot;aName&quot;, &quot;aValue&quot;).compact();&#10;       &#10;instead of this:&#10;       Claims claims = Jwts.claims().put(&quot;aName&quot;, &quot;aValue&quot;);&#10;       String jwt = Jwts.builder().setClaims(claims).compact();&#10;       &#10;if desired.&#10;Params:&#10;name – the JWT Claims property name&#10;value – the value to set for the specified Claims property name&#10;Returns:&#10;the builder instance for method chaining." />
      <item value="Sets the JWT Claims exp (expiration) value. A null value will remove the property from the Claims.&#10;A JWT obtained after this timestamp should not be used.&#10;This is a convenience method. It will first ensure a Claims instance exists as the JWT body and then set the Claims expiration field with the specified value. This allows you to write code like this:&#10;       String jwt = Jwts.builder().setExpiration(new Date(System.currentTimeMillis() + 3600000)).compact();&#10;       &#10;instead of this:&#10;       Claims claims = Jwts.claims().setExpiration(new Date(System.currentTimeMillis() + 3600000));&#10;       String jwt = Jwts.builder().setClaims(claims).compact();&#10;       &#10;if desired.&#10;Params:&#10;exp – the JWT exp value or null to remove the property from the Claims map.&#10;Returns:&#10;the builder instance for method chaining." />
      <item value="replace default Configuration class" />
      <item value="dangling" />
      <item value="Dangling" />
      <item value="segment" />
      <item value="authority" />
      <item value="Return the body of the message as a Publisher.&#10;Returns:&#10;the body content publisher" />
      <item value="Return the request attribute value or if not present raise an" />
      <item value="Return the current HTTP request." />
      <item value="An &quot;reactive&quot; HTTP input message that exposes the input as Publisher.&#10;Typically implemented by an HTTP request on the server-side or a response on the client-side." />
      <item value="Defines an object to provide client request information to a servlet. The servlet container creates a ServletRequest object and passes it as an argument to the servlet's service method.&#10;A ServletRequest object provides data including parameter name and values, attributes, and an input stream. Interfaces that extend ServletRequest can provide additional protocol-specific data (for example, HTTP data is provided by javax.servlet.http.HttpServletRequest.&#10;See Also:&#10;javax.servlet.http.HttpServletRequest" />
      <item value="A Publisher is a provider of a potentially unbounded number of sequenced elements, publishing them according to the demand received from its Subscriber(s).&#10;A Publisher can serve multiple Subscribers subscribed subscribe(Subscriber) dynamically at various points in time.&#10;Type parameters:&#10;&lt;T&gt; – the type of element signaled." />
      <item value="A Reactive Streams Publisher with rx operators that emits 0 to N elements, and then completes (successfully or with an error).&#10;The recommended way to learn about the Flux API and discover new operators is through the reference documentation, rather than through this javadoc (as opposed to learning more about individual operators). See the &quot;which operator do I need?&quot; appendix .&#10; &#10;It is intended to be used in implementations and return types. Input parameters should keep using raw Publisher as much as possible.&#10;If it is known that the underlying Publisher will emit 0 or 1 element, Mono should be used instead.&#10;Note that using state in the java.util.function  lambdas used within Flux operators should be avoided, as these may be shared between several Subscribers.&#10;subscribe(CoreSubscriber) is an internal extension to subscribe(Subscriber) used internally for Context passing. User provided Subscriber may be passed to this &quot;subscribe&quot; extension but will loose the available per-subscribe Hooks.onLastOperator." />
      <item value="Basic abstraction over byte buffers.&#10;DataBuffers has a separate read and write position, as opposed to ByteBuffer's single position. As such, the DataBuffer does not require a flip to read after writing. In general, the following invariant holds for the read and write positions, and the capacity:&#10;0 &lt;= readPosition &lt;= writePosition &lt;= capacity&#10;The capacity of a DataBuffer is expanded on demand, similar to StringBuilder.&#10;The main purpose of the DataBuffer abstraction is to provide a convenient wrapper around ByteBuffer which is similar to Netty's io.netty.buffer.ByteBuf but can also be used on non-Netty platforms (i.e. Servlet containers).&#10;Since:&#10;5.0&#10;See Also:&#10;DataBufferFactory&#10;Author:&#10;Arjen Poutsma, Brian Clozel" />
      <item value="Get the order value of this object.&#10;Higher values are interpreted as lower priority. As a consequence, the object with the lowest value has the highest priority (somewhat analogous to Servlet load-on-startup values).&#10;Same order values will result in arbitrary sort positions for the affected objects.&#10;Returns:&#10;the order value" />
      <item value="Useful constant for the highest precedence value." />
      <item value="Useful constant for the highest precedence value.&#10;See Also:&#10;Integer.MIN_VALUE" />
      <item value="Return the SSL session information if the request has been transmitted over a secure protocol including SSL certificates, if available.&#10;Returns:&#10;the session information, or null if none availabl" />
      <item value="Annotation to mark a RestTemplate or WebClient bean to be configured to use a LoadBalancerClient.&#10;Author:&#10;Spencer Gibb" />
      <item value="      Main method and entry point when starting Tomcat via the provided&#10;      scripts.&#10;     &#10;      @param args Command line arguments to be processed" />
      <item value="Bootstrap loader for Catalina. This application constructs a class loader for use in loading the Catalina internal classes (by accumulating all of the JAR files found in the &quot;server&quot; directory under &quot;catalina.home&quot;), and starts the regular execution of the container. The purpose of this roundabout approach is to keep the Catalina internal classes (and any other classes they depend on, such as an XML parser) out of the system class path and therefore not visible to application level classes.&#10;Author:&#10;Craig R. McClanahan, Remy Maucherat" />
      <item value="The rx operators will offer aliases for input Mono type to preserve the &quot;at most one&quot; property of the resulting Mono. For instance flatMap returns a Mono, while there is a flatMapMany alias with possibly more than 1 emission.&#10;Mono&lt;Void&gt; should be used for Publisher that just completes without any value.&#10;It is intended to be used in implementations and return types, input parameters should keep using raw Publisher as much as possible.&#10;Note that using state in the java.util.function  lambdas used within Mono operators should be avoided, as these may be shared between several Subscribers.&#10;See Also:&#10;Flux&#10;Author:&#10;Sebastien Deleuze, Stephane Maldini, David Karnok, Simon Baslé&#10;Type parameters:&#10;&lt;T&gt; – the type of the single value of this class" />
      <item value="retain" />
      <item value="Transform the item emitted by this Mono asynchronously, returning the value emitted by another Mono (possibly changing the value type).&#10; &#10;Params:&#10;transformer – the function to dynamically bind a new Mono&#10;Type parameters:&#10;&lt;R&gt; – the result type bound&#10;Returns:&#10;a new Mono with an asynchronously mapped value." />
      <item value="Obtain a InputStream from the given supplier, and read it into a Flux of DataBuffers. Closes the input stream when the Flux is terminated.&#10;Params:&#10;inputStreamSupplier – the supplier for the input stream to read from&#10;bufferFactory – the factory to create data buffers with&#10;bufferSize – the maximum size of the data buffers&#10;Returns:&#10;a Flux of data buffers read from the given channel" />
      <item value="Utility class for working with DataBuffers.&#10;Since:&#10;5.0&#10;Author:&#10;Arjen Poutsma, Brian Clozel" />
      <item value="Add a specific Expires At (&quot;exp&quot;) claim to the Payload.&#10;Params:&#10;expiresAt – the Expires At value.&#10;Returns:&#10;this same Builder instance." />
      <item value="dd a specific Expires At (&quot;exp&quot;) claim to the Payload.&#10;Params:&#10;expiresAt – the Expires At value.&#10;Returns:&#10;this same Builder instance." />
      <item value="Returns:&#10;a JWTCreator.Builder instance to configure." />
      <item value="Useful constant for the highest precedence value" />
      <item value="Indicate that message handling is complete, allowing for any cleanup or end-of-processing tasks to be performed such as applying header changes made via getHeaders() to the underlying HTTP message (if not applied already).&#10;This method should be automatically invoked at the end of message processing so typically applications should not have to invoke it. If invoked multiple times it should have no side effects.&#10;Returns:&#10;a Mono that indicates completion or error" />
      <item value="Thrown when a thread is waiting, sleeping, or otherwise occupied, and the thread is interrupted, either before or during the activity. Occasionally a method may wish to test whether the current thread has been interrupted, and if so, to immediately throw this exception. The following code can be used to achieve this effect:&#10;    if (Thread.interrupted())   Clears interrupted status!&#10;        throw new InterruptedException();" />
      <item value="Interrupted Exception" />
      <item value="Following columns have no computeddefault value and must be listed explicitly: phone_fingerprint " />
      <item value="Creates a new instance&#10;Params:&#10;allowed – the origins that are allowed." />
      <item value="Specify to allow any request that comes from the same origin to frame this application. For example, if the application was hosted on example.com, then example.com could frame the application, but evil.com could not frame the application.&#10;Returns:&#10;the HeadersConfigurer for additional customization" />
      <item value="Collect" />
      <item value="Manipulation" />
      <item value="翻译文档失败: 翻译失败: 未知错误&#10;&#10;&gt;Plugin v3.2.0.1  &#10;&gt;IntelliJ IDEA 2021.1.2  &#10;&gt;Build #IU-211.7442.40, built on June 1, 2021  &#10;&gt;Runtime version: 11.0.11+9-b1341.57 amd64  &#10;&gt;VM: Dynamic Code Evolution 64-Bit Server VM by JetBrains s.r.o.  &#10;&gt;OS: Windows 10 10.0&#10;&#10;```&#10;cn.yiiguxing.plugin.translate.trans.TranslateException: Google 翻译 :: 翻译失败: 未知错误&#10;&#9;at cn.yiiguxing.plugin.translate.trans.AbstractTranslator.onError(AbstractTranslator.kt:47)&#10;&#9;at cn.yiiguxing.plugin.translate.trans.google.GoogleTranslator.onError(GoogleTranslator.kt:131)&#10;&#9;at cn.yiiguxing.plugin.translate.trans.AbstractTranslator.access$onError(AbstractTranslator.kt:16)&#10;&#9;at cn.yiiguxing.plugin.translate.trans.google.GoogleTranslator.translateDocumentation(GoogleTranslator.kt:158)&#10;&#9;at cn.yiiguxing.plugin.translate.documentation.HtmlTranslatorKt.getTranslatedDocumentation(HtmlTranslator.kt:110)&#10;&#9;at cn.yiiguxing.plugin.translate.documentation.HtmlTranslatorKt.getTranslatedDocumentation(HtmlTranslator.kt:47)&#10;&#9;at cn.yiiguxing.plugin.translate.documentation.TranslateDocumentationTask$special$$inlined$runAsync$1.run(promise.kt:402)&#10;&#9;at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)&#10;&#9;at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)&#10;&#9;at java.base/java.util.concurrent.Executors$PrivilegedThreadFactory$1$1.run(Executors.java:668)&#10;&#9;at java.base/java.util.concurrent.Executors$PrivilegedThreadFactory$1$1.run(Executors.java:665)&#10;&#9;at java.base/java.security.AccessController.doPrivileged(Native Method)&#10;&#9;at java.base/java.util.concurrent.Executors$PrivilegedThreadFactory$1.run(Executors.java:665)&#10;&#9;at java.base/java.lang.Thread.run(Thread.java:829)&#10;Caused by: java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 1&#10;&#9;at cn.yiiguxing.plugin.translate.trans.google.GoogleTranslator.parseDocTranslation(GoogleTranslator.kt:125)&#10;&#9;at cn.yiiguxing.plugin.translate.trans.google.GoogleTranslator.access$parseDocTranslation(GoogleTranslator.kt:16)&#10;&#9;at cn.yiiguxing.plugin.translate.trans.google.GoogleTranslator$translateDocumentation$1$client$2.invoke(GoogleTranslator.kt:58)&#10;&#9;at cn.yiiguxing.plugin.translate.trans.google.GoogleTranslator$translateDocumentation$1$client$2.invoke(GoogleTranslator.kt:58)&#10;&#9;at cn.yiiguxing.plugin.translate.trans.SimpleTranslateClient.parse(SimpleTranslateClient.kt:19)&#10;&#9;at cn.yiiguxing.plugin.translate.trans.TranslateClient.execute(TranslateClient.kt:51)&#10;&#9;at cn.yiiguxing.plugin.translate.trans.google.GoogleTranslator.translateDocumentation(GoogleTranslator.kt:62)&#10;&#9;... 10 more&#10;```&#10;" />
      <item value="Usage model. To motivate the behavior of add() and roll(), consider a user interface component with increment and decrement buttons for the month, day, and year, and an underlying GregorianCalendar. If the interface reads January 31, 1999 and the user presses the month increment button, what should it read? If the underlying implementation uses set(), it might read March 3, 1999. A better result would be February 28, 1999. Furthermore, if the user presses the month increment button again, it should read March 31, 1999, not March 28, 1999. By saving the original date and using either add() or roll(), depending on whether" />
      <item value="unpacker" />
      <item value="Thrown by HttpMessageConverter implementations when the HttpMessageConverter.read method fails.&#10;Since:&#10;3.0&#10;Author:&#10;Arjen Poutsma, Juergen Hoeller" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1182" />
        <entry key="ENGLISH" value="1182" />
        <entry key="DANISH" value="2" />
        <entry key="FRISIAN" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="JAPANESE" value="1" />
        <entry key="INDONESIAN" value="2" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1645494939321" />
  </component>
  <component name="Settings">
    <option name="autoReplace" value="true" />
    <option name="keepFormat" value="true" />
    <option name="selectTargetLanguageBeforeReplacement" value="true" />
    <option name="showActionsInContextMenuOnlyWithSelection" value="false" />
    <option name="showExplanation" value="true" />
    <option name="showWordsOnStartup" value="true" />
    <option name="translateDocumentation" value="true" />
  </component>
</application>